	In primul rand aceasta tema mi s-a parut foarte interesanta pentru ca m-a ajutat
sa inteleg mai bine cum se folosesc parserele si la ce ne ajuta. Ca dificultate
mi s-a parut o tema de dificultate medie. Pentru mine partea dificila a fost partea
de inceput pentru ca nu stiam exact ce si cum trebuie sa fac. In continuare o sa 
explic cum am implementat tema.

Partea JFLEX

	Cum am spus si mai sus partea dificila a fost la inceput, pana mi-am dat seama
cum sa creez un nod si cum sa lucrez cu stiva. Astfel am rezolvat tema in urmatorul fel:

	Pentru inceput citesc declararea variabilelor si le retin intr-un hashmap numit
variables. Acest hashmap este declarat static pentru a fi accesat si din clasele
din fisierul types.java. Initial toate variabilele au valoarea null.

	In continuare se citeste din fisierul de input si se pun pe stiva diferite noduri
in functie de valoarea citita (ex: daca se citeste o valoare booleana se pune pe stiva
un nod de tipul BVal). Atunci cand se citeste de la input ";" se reduc nodurile puse pe stiva
pana in acel moment in urmatorul fel: se verifica daca al doilea element de pe stiva este
o operatie. Daca este o operatie se formeaza nodul specific operatiei si se reia procesul, 
adica se verifica daca mai exista vreo operatie pe stiva, iar daca exista, se creeaza
un nod operatie intre nodul proaspat creat si orice alt nod care mai este pe stiva. Acest lucru
se repeta pana cand pe stiva nu mai este nici o operatie. Asemenator se face si atunci
cand se citeste ")" sau "}" numai ca reducerea nu se face pana cand nu mai este nici o
operatie pe stiva ci pana cand se intalneste "(" sau "{". Astfel se creeaza bracketnode
sau blocknode.

	Un alt lucru important din implementarea mea este partea in care am asigurat
diferitele prioritati pentru operatii. Fiecare tip de operatie (logica sau aritmetica)
are o anumita prioritate si anume: 1 -> "&&", 2 -> ">", 3 -> "!", 4 -> "+", 5 -> "/".
Atunci cand o operatie este citita de la input, se verifica daca prioritatea operatiei
deja pusa pe stiva (daca exista) este mai mare decat prioritatea operatiei care 
trebuie pusa pe stiva, daca aceasta conditie este indeplinita, atunci trebuie redusa
operatia care deja se afla pe stiva. Dupa ce se reduce operatia de pe stiva, se repeta procesul
pana cand conditia nu mai este indeplinita, dupa care se pune operatorul nou pe 
stiva. De exemplu daca pe stiva se afla un nod de tip "/" si trebuie pus un nod de 
tip "+" pe stiva, atunci se reduce mai intai operatia "/" de pe stiva dupa care se
pune nodul "+".

	Eroarea de tipul UnassignedVar cand variabila citita nu este declarata este
tratata tot la citire, si anume daca pe parcursul parsarii inputului se citeste o
variabila care nu se gaseste in hashmapul initial atunci se adauga eroarea in
in lista de erori. Daca la sfarsitul citirii lista de erori nu este goala atunci 
se printeaza eroarea si nu se mai printeaza valoarea variabilelor.

	Partea de interpretarea si tratarea celorlalte tipuri de erori (la rulare)
am rezolvat-o in urmatorul fel:

	Fiecare tip de nod din fisierul types.java are un camp valoare si o functie de tipul
: Object getValue().

	Pentru tipurile primitive cum ar fi variabila, valoare aritmetica si valoare
booleana functia getValue intoarce un String, un integer sau un boolean. Pentru celelalte
tipuri de noduri functia getValue() intoarce fie null, daca nodul respectiv nu va
fi folosit la interpretare, fie valoarea corespunzatoare calculata din copii nodului respectiv
(de exemplu daca este un plus node functia getValue() va intoarce copil1.getValue() + 
copil2.getValue()), fie daca nodul este unul de tip AssignmentNode atunci functia getValue()
va updata valoare variabilei in hashmapul de valori si va intoarce null.

	Pentru nodurile de tip if functia getValue arata in urmatorul fel:

		if (cond.getValue()) then
			branch1.getValue()
		else
			branch2.getValue()

	Pentru nodurile while:

		while (cond.getValue()) then
			branch.getValue()

	Nodul AssignmentNode este cel mai imporant deoarece in funcia sa getValue()
se realizeaza practic asignarile de valori. 

	Pentru celelalte 2 tipuri de erori: 

	- pentru division by zero, in functia getValue() a nodului DivNode se verifica daca
impartitorul are valoarea 0, daca da atunci se activeaza un flag error care spune ca
a fost intampinata o eroare iar campul errorString este initializat cu continutul 
corespunzator.

	- pentru unnasignedvar atunci cand variabila a fost declarata dar nu i-a fost
atribuita o valoare: atunci cand un nod aritmetic are unul din copii o variabila
iar variabila are valoarea null in hashmap se activeaza flagul de eroare si se 
initializeaza campul errorString cu continutul corespunzator.

	In final in functia main se realizeaza urmatorele lucruri:

	-se citeste inputul si se pun pe stiva diferitele noduri create dupa cum am 
explicat mai sus

	-se realizeaza arborele final prin reducerea nodurilor de pe stiva intr-unul
singur in functia reduceStack()

	-se printeaza arborele in fisierul arbore

	-se interpreteaza programul

	-se verifica daca au fost intampinate erori pe parcursul parsarii sau interpretarii
programului, daca da, atunci se printeaza erorile, daca nu, se printeaza valorile
variabilelor.

DANIEL DINCA, 336CB